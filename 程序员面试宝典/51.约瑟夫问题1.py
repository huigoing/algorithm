# -*- coding: utf-8 -*-
"""
Created on Wed Jul 10 16:01:04 2019

@author: Tang
"""

'''
题目描述



约瑟夫问题是一个非常著名的趣题，即由n个人坐成一圈，按顺时针由1开始给他们编号。然后由第一个人开始报数，数到m的人出局。现在需要求的是最后一个出局的人的编号。

给定两个int n和m，代表游戏的人数。请返回最后一个出局的人的编号。保证n和m小于等于1000。

测试样例：
5 3
返回：4

无论是用链表实现还是用数组实现都有一个共同点：要模拟整个游戏过程，不仅程序写起来比较烦，而且时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果的。我们注意到原问题仅仅是要求出最后的胜利者的序号，而不是要读者模拟整个过程。因此如果要追求效率，就要打破常规，实施一点数学策略。 

为了讨论方便，先把问题稍微改变一下，并不影响原意： 
问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。 

我们知道第一个人(编号一定是m%n-1) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）: 
  k  k+1  k+2  ... n-2, n-1, 0, 1, 2, ... k-2并且从k开始报0。 
现在我们把他们的编号做一下转换： 

k     --> 0 
k+1   --> 1 
k+2   --> 2 
... 
... 
k-2   --> n-2 
k-1   --> n-1 
变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x'=(x+k)%n 

如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况 ---- 这显然就是一个倒推问题！好了，思路出来了，下面写递推公式： 

令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n] 

递推公式 
f[1]=0; 
f[i]=(f[i-1]+m)%i;  (i>1) 
'''
def solution(n,m):
     s=0
     for i in range(2,n+1):
          s=(s+m)%i
     return s+1
a=list(range(1,11))
print(a)
print(a[::2])
print(a[:-1])
b=[111,5]
print(a+b)